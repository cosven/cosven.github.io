* 零散
** tcpdump usage

TCP FLAGS

PSH     =  [P] (Push Data)
RST     =  [R] (Reset Connection)
SYN     =  [S] (Start Connection)
FIN     =  [F] (Finish Connection)
SYN-ACK =  [S.] (SynAcK Packet)
           [.] (No Flag Set)

- 指定 interface =tcpdump -i en0=
- 指定主机和端口 =tcpdump tcp port 23 and host 10.1.0.1=

Q：在 osx 上，建立连接会有 4 次握手？
#+BEGIN_SRC
19:29:37.157437 IP localhost.54871 > localhost.23333: Flags [S], seq 4183558234, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 3374013330 ecr 0,sackOK,eol], length 0
19:29:37.157538 IP localhost.23333 > localhost.54871: Flags [S.], seq 1658355569, ack 4183558235, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 3374013330 ecr 3374013330,sackOK,eol], length 0
19:29:37.157554 IP localhost.54871 > localhost.23333: Flags [.], ack 1, win 12759, options [nop,nop,TS val 3374013330 ecr 3374013330], length 0
19:29:37.157567 IP localhost.23333 > localhost.54871: Flags [.], ack 1, win 12759, options [nop,nop,TS val 3374013330 ecr 3374013330], length 0
#+END_SRC

在 wireshark 中可以发现，最后一个包的作用是 TCP WINDOW UPDATE，并不是必须的。
在 Linux 上测试的话，我们可以发现，不会出现最后这个包。
那为什么要有 TCP WINDOW UPDATE 这么一次操作呢？暂不深究 [[https://stackoverflow.com/questions/1466307/what-is-a-tcp-window-update][参考资料]]

** 用 dnsmasq 干点小事情
*本笔记只记录 dnsmasq 作为域名解析服务器的一些用法及原理解释*
dnsmasq 能干啥？可以把它用作域名解析服务器，缓存 DNS 请求结果。
*** 一个大致的域名解析过程

1. 程序发起一个 DNS query
2. 看 hosts 文件是否有 IP 地址映射，没有的话看本地 DNS 缓存
3. 从 /etc/resolv.conf 获取 dns server 地址
4. 将 DNS query 请求丢给 DNS server
5. 然后 DNS server 进行一系列事情帮助完成解析

dnsmasq 在这个步骤中充当 DNS server 的作用
牢记：它充当的是 DNS server 的作用。

*** 下面是在 osx 下安装使用 dnsmasq 的的记录

1. 安装启动 dnsmasq
```
brew install dnsmasq
sudo brew services start dnsmasq
# 使用下面命令看看 53 端口是否被 dnsmasq 占用
# sudo lsof -i:53
```
2. 解析 awesome.mine 域名

*操作流程理论分析*

1. 启动 dnsmasq (启动一个 dns server，它的地址默认是 127.0.0.1)
2. 配置 dnsmasq，让它解析 awesome.mine 域名
3. 在 /etc/resolv.conf 加入 dns server 地址（127.0.0.1）
4. OK

*具体的操作命令*

```
# vi /usr/local/etc/dnsmasq.conf
# 在最下面加入一行
# `address=/mine/127.0.0.1`

# vi /etc/resolv.conf
# 在前面加入一行
# `namesearver 127.0.0.1`

# sudo brew services restart dnsmasq
```

** K8s 的 DNS 拼接
- 访问 svc 地址：在 namespace 内部可以这样访问： ={svc_name}.{namespace}= 。
  举个例子： =nc tc-tidb.cosven-sysbench-s4ncr 4000= 。
- 访问 pod 地址：
  举个例子： =nc tc-tidb-0.tc-tidb-peer.cosven-sysbench-s4ncr 4000= 。

** KVM 安装虚拟机
*** 一个示例脚本

```sh
#!/bin/bash

virt-install --name=cosven-dev \
  --vcpus=8 \
  --memory=16384 \
  --graphics vnc,listen=0.0.0.0 \
  --console pty,target_type=serial \
  --cdrom=/data0/cosven/ubuntu-18.04.4-live-server-amd64.iso \
  --disk path=/data0/vms/cosven-dev,size=128,format=qcow2,sparse=false \
  --os-variant=ubuntu18.04 \
  --debug
```

*** 初始化一台 linux 机器供自己使用

1. 免密登录服务器 id_rsa.pub -> authorized_keys
2. git clone git@github.com:cosven/rcfiles.git
3. git clone git@github.com:cosven/.emacs.d.git
4. 安装 https://github.com/BurntSushi/ripgrep
5. 安装 fzf https://github.com/junegunn/fzf#using-git

*** 在 linux 启动一个 http proxy

关于 proxy：几乎所有 linux 软件都会识别 `http_proxy` 这个环境变量，
还有一部分软件会识别 `all_proxy` 这个环境变量，
比如 `export all_proxy="socks5://127.0.0.1:1090"`

1. 简易临时的 proxy 可以使用 ssh 的 socks proxy `ssh -D PORT USER@HOST`
2. 简易不临时的推荐使用 [tinyproxy](https://www.archlinux.org/packages/?name=tinyproxy)。
   apt/aur 都可以直接安装。使用前将配置文件（一般在 `/etc/tinyproxy/tinyproxy.conf`）
   中的 `Allow 127.0.0.1` 注释掉，这样就可以允许所有连接了。

`all_proxy` 据说一般是用来设置 socks 代理地址的，已知的是 curl 会识别它。
目前没有搜到关于这个环境变量的官方的解释。

简单搜索了下，它可以转发 TCP/UDP 请求。大概可以理解为它在真正的 IP 包上又包了一层。

#### 如何让 git 使用 proxy 呢？

暂时想到的办法是让 git 走 http 协议来 push `git push http://xx master`。
如果 `git push git@github..` 这种形式的话，目前还没找到好办法。
讲道理它应该也是走 socks 代理的才对，如果 git 内部支持的话，但实测好像不行。

*** 放开 Open Files 限制
修改 `/etc/security/limits.conf` 文件配置，添加一行 nofile 的配置

#+BEGIN_SRC
  #ftp             -       chroot          /ftp
  #@student        -       maxlogins       4
  *                -       nofile          1000000
  # End of file
#+END_SRC

这个对已经启动的 bash 的子进程不生效，还可能对某些系统不生效，希望后面可以补充下。
另外有个问题：
- [ ] A 主机达到 limit，B 主机尝试建立与 A 的链接，B 收到的是什么？timeout/refused？
