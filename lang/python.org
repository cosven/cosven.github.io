* Python

我自己获取 Python 资源的途径：

1. twitter - 关注 core developer (尝试中)
2. [[https://reddit.com/r/python][/r/python]] - 尝试过一段实践（可以看一些社区新闻）
3. 关注看到过的一些不错的博客
4. 主动通过搜索引擎搜索关键字（比如 Python dataclasses）

** Flask
*** Flask 中使用线程池
** Gunicorn

** SQLAlchemy
*** TODO [#C] 问题排差：2013, 'Lost connection to MySQL server during query'
** TODO [#B] Python 3.7 Dataclasses

- [ ] 为什么要加入 dataclasses？
  - 不是已经有 attr 了么？
- [X] dataclasses 基本用法（讲基础用法的文章很多）
- [ ] dataclasses 和 Model/Serializer/Schema 等概念的关系是怎样的？
  - 要不要内置支持 validation？
  - 现有资料没有谈这几个东西之间的关联

*高级话题*

- [ ] 据说 dataclasses 没有使用 metaclass，那它是怎样实现的呢？

*主要参考资料：*

- [[https://www.python.org/dev/peps/pep-0557/][PEP 557]]
- [[https://docs.python.org/3/library/dataclasses.html][Python docs]]

*** 为什么要有 dataclasses？

Guido:([[https://github.com/ericvsmith/dataclasses/issues/19#issuecomment-310913558][link]])
#+BEGIN_QUOTE
I would say the stdlib is lacking some very useful functionality in this area.
#+END_QUOTE


kawabangga:([[https://www.kawabangga.com/posts/2959][对比于 attr, Namedtyple 等其它容器]])
#+BEGIN_QUOTE

1. 没有使用 BaseClass 或者 metaclass，不会影响代码的继承关系。
   被装饰的类依然是一个普通的类
2. 使用类的 Fields 类型注解，用原生的方法支持类型检查，不像 attr 这种库对代码有侵入性
   （要用 attr 的函数将一些东西处理）
#+End_quote

*** Dataclasses 和 Model, Schema, Serializer 这些概念的联系是什么？

** 一些奇怪的坑
*** try...except... 使用的一个注意事项
这段代码看起来是 A 模块不存在，但其实还有一种可能，A 模块依赖的一个模块不存在。
#+BEGIN_SRC python
try:
    import A
except ImportError:
    print('A not found.')
#+END_SRC

另外一个现实中的例子：[[https://github.com/pallets/werkzeug/commit/b488d7ed5c88619191e89acbb642db2c03e13e2c][werkzeug: Fix import_string masking of AttributeError]]

** 字符串
Q: 字符串 format 如何得到这种 {value} 形式的字符串

```python
'{{{hosts}}}'.format(hosts=','.join(['hello', 'world']))
```

** 描述符
问题：A.b, a.b 分别是如何工作的？

#+BEGIN_SRC python
class A(object):
    @property
    def h(self):
        return 1

a = A()
#+END_SRC

[参考链接](https://docs.python.org/3/howto/descriptor.html#invoking-descriptors)

> For objects, the machinery is in `object.__getattribute__()` which transforms b.x
into `type(b).__dict__['x'].__get__(b, type(b))`. The implementation works through
a precedence chain that gives data descriptors priority over instance variables,
instance variables priority over non-data descriptors, and assigns lowest priority
to `__getattr__()` if provided. The full C implementation can be found in
PyObject_GenericGetAttr() in Objects/object.c.

> For classes, the machinery is in `type.__getattribute__()` which transforms B.x
into `B.__dict__['x'].__get__(None, B)`. In pure Python, it looks like:

** Abstract Class Attribute
本意是想要求子类必须实现下面几个类属性，但是并没有
abstract-class-property 装饰器。另外，无论在这里设置该字段为
abstractproperty 还是 abstractmethod，子类只要有个同名字段，它
就能正常实例化，所以这里为了代码看起来相对简单，直接使用
abstractmethod 来装饰这几个字段。

#+BEGIN_SRC python
class AbstractXxx(ABC):
    @abstractmethod
    def Song(self):
        pass
#+END_SRC

而按照对 ABC 的理解，正确的方式可能是要这样写::
#+BEGIN_SRC
    @property
    @classmethod
    @abstractmethod
    def Song(self):
        pass
#+END_SRC

** setup.py 常见命令的执行逻辑
1. bdist_wheel 是 wheel 包提供的
2. 使用 MANIFEST.in，而不是 package_data
3. 创建一个零时的包占坑（没有找到其他好办法）

#+begin_src
build
 -> build_py
 -> build_clib
 -> build_ext
 -> build_scripts

sdist
 -> check
   -> check_metadata

install
 -> build
 -> install_lib
   -> build_py if has_pure_modules
   -> build_ext if has_ext_modueles
 -> install_headers
 -> install_scripts
 -> install_data
 -> install_data
 -> install_egg_info
#+end_src

:LOGBOOK:
1. build 可能需要一个 id
:END:

thrift-compiler -> gen-py/
package_dir={'': 'gen-py'}
packages=find_packages('gen-py')

不能安装 gen-py/ 目录下的包到系统环境
or 预先在 gen-py 目录下创建好包
